import from agents { codeGenius_impl }
# -------------------------------------------
# Implementation of RepoMapper
# -------------------------------------------

impl RepoMapper.build_file_tree {
    # In real code: clone repo, walk files, filter ignored paths
    # For demo: return static structure
    self.file_tree = {
        "src/": {"main.py": {}, "core/": {"engine.py": {}}},
        "README.md": {},
        "requirements.txt": {}
    };
    return self.file_tree;
}

impl RepoMapper.summarize_readme {
    # In real code: fetch and summarize README.md
    self.readme_summary = "AI DocGen: Auto-generates developer documentation from code using LLMs and static analysis.";
    return self.readme_summary;
}

sem RepoMapper.map_repository = """
Analyze the GitHub repository to produce two artifacts:
1. A clean file tree (excluding .git, node_modules, etc.)
2. A one-sentence summary of the README.md

Call BOTH tools: build_file_tree AND summarize_readme.
Return a confirmation message like 'Repository mapped successfully.'
""";

# -------------------------------------------
# Implementation of CodeAnalyzer
# -------------------------------------------

impl CodeAnalyzer.parse_file_with_treesitter {
    # Simulate parsing: create CCG nodes/edges under self.ccg_root
    mod = self.ccg_root ++> Module(name="main", file_path=filepath);
    train_fn = mod +>:Contains:+> Function(name="train_model", file_path=filepath);
    preprocess_fn = mod +>:Contains:+> Function(name="preprocess_data", file_path=filepath);
    train_fn +>:Calls:+> preprocess_fn;
    self.parsed_results[filepath] = {"functions": ["train_model", "preprocess_data"]};
    return true;
}

impl CodeAnalyzer.build_code_context_graph {
    self.ccg_root = root ++> node();
    for f in file_list {
        self.parse_file_with_treesitter(f);
    }
    return self.ccg_root;
}

impl CodeAnalyzer.get_callers {
    # Traverse CCG to find callers (simplified)
    if func_name == "train_model" {
        return ["main"];
    }    
    return [];
}

sem CodeAnalyzer.analyze_codebase = """
Build a Code Context Graph (CCG) by parsing all source files.
Then, if asked, answer specific queries like 'Which functions call X?'.
Always call build_code_context_graph first.
Only call query tools (e.g., get_callers) if explicitly needed.
""";

# -------------------------------------------
# Implementation of DocGenie
# -------------------------------------------

impl DocGenie.render_overview {
    return f"##  Project Overview\n\n{readme_summary}\n";
}

impl DocGenie.render_installation {
    has_reqs = "requirements.txt" in str(file_tree);
    if has_reqs:
        return "##  Installation\n\n```bash\npip install -r requirements.txt\n```\n";
    return "##  Installation\n\nRefer to the repository for setup.\n";
}

impl DocGenie.render_usage {
    entry = [f for f in keys(file_tree) if "main" in f];
    if entry:
        return f"##  Usage\n\n```bash\npython {entry[0]}\n```\n";
    return "##  Usage\n\nSee source files for entry points.\n";
}

impl DocGenie.render_api_reference {
    lines = ["## API Reference\n"];
    for file, meta in code_meta.items():
        lines.append(f"### `{file}`\n");
        for fn in meta.get("functions", []):
            lines.append(f"- **`{fn}`** – _Description placeholder._");
    return "\n".join(lines);
}

impl DocGenie.generate_diagram {
    return "## System Diagram\n\n```mermaid\ngraph LR\n  main --> train_model\n  train_model --> preprocess_data\n```\n";
}

sem DocGenie.generate_documentation = """
Generate a complete markdown document with these sections in order:
1. Project Overview
2. Installation
3. Usage
4. API Reference
5. System Diagram (if include_diagrams is true)

Call each rendering tool exactly once.
Do NOT invent content—use only the provided structured data.
Return the full markdown as a single string.
""";